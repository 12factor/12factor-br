## III. 配置
### 在环境中存储配置(*Config*)

通常，应用的 *配置* 在不同 [部署](/codebase) (预发布、生产环境、开发环境等等)间会有很大差异。这其中包括：

* 数据库，Memcached，以及其他 [后端服务](/backing-services) 的配置
* Amazon S3或是Twitter等第三方服务的证书
* 每种部署独特的域名等各个部署间不同的内容

有些应用将配置在代码中写为常量。这与twelve-factor所要求的 **代码和配置严格分离** 显然大相径庭。配置文件在各部署间存在大幅差异，代码却完全一致。

衡量一个应用是否正确的将配置排除在代码之外的一个有效方法是，该应用的代码库是否可以随时开源而不做任何修改。

需要特别注意的是，这里定义的"配置"并 **不** 包括应用的内部配置，比如Rails的 `config/routes.rb`，又或是 [Spring](http://www.springsource.org/) 的 [how code modules are connected](http://static.springsource.org/spring/docs/2.5.x/reference/beans.html) 。这类配置在不同部署间不存在差异，所以存在代码中是最好的选择。

另外一个解决配置的方式是使用配置文件，但不把它们签入版本控制系统，就像Rails的 `config/database.yml` 。这相对将常量直接签入代码库已经是长足进步，但仍然有缺点：总是会不小心将配置文件签入了代码库；配置文件的一个趋势是它们分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。

**Twelve-factor推崇将应用的配置存储于 *环境变量*** (通常称之为 *env vars* 或 *env*) 。Env vars可以非常方便的在不同部署间做修改，却不动一行代码；与配置文件不同，不小心把它们签入代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如Java System properties）相比，它们与语言和系统无关。

配置管理的另一个方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如Rails中的 `development`,`test`, 和 `production` 环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如 `staging` 或 `qa` 。 随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如 `joes-staging` ，这将导致各种配置组合的爆炸，从而给管理部署增加了很多不确定因素。

Twelve-factor应用中，env vars的粒度足够小，相互之间也是相对独立的。它们永远不会合体组成一个所谓的“环境”，而是独立管理每个部署。这是应用的生命周期中扩展出更多部署时较为平滑的模型。

